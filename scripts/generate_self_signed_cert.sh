#!/usr/bin/env bash

# Self-Signed Certificate Generator
# Creates TLS certificates for development/testing purposes
# Supports both domain names and IP addresses
# Generated by Claude Opus 4.1 on 25 Aug, 2025

set -euo pipefail

# Colors for better UX
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly BOLD='\033[1m'
readonly NC='\033[0m' # No Color

# Default values
readonly DEFAULT_DAYS=365
readonly DEFAULT_BITS=2048
readonly DEFAULT_OUTPUT_DIR="./nginx"
readonly DEFAULT_CERT_NAME="cert.pem"
readonly DEFAULT_KEY_NAME="key.pem"

# Script variables
DOMAINS=()
IP_ADDRESSES=()
OUTPUT_DIR="$DEFAULT_OUTPUT_DIR"
CERT_PATH=""
KEY_PATH=""
DAYS="$DEFAULT_DAYS"
BITS="$DEFAULT_BITS"
COMMON_NAME=""

# Cleanup function
cleanup() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        echo -e "\n${RED}✗ Certificate generation failed${NC}"
        echo -e "${YELLOW}If you encountered an error:${NC}"
        echo "  • Ensure openssl is installed: which openssl"
        echo "  • Check write permissions for: $OUTPUT_DIR"
        echo "  • Review the error messages above"
    fi
    exit $exit_code
}

trap cleanup EXIT

# Print banner
print_banner() {
    echo -e "${BLUE}${BOLD}"
    echo "═══════════════════════════════════════════════════"
    echo "    Self-Signed Certificate Generator"
    echo "═══════════════════════════════════════════════════"
    echo -e "${NC}"
}

# Print help
print_help() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS]

OPTIONS:
    -h, --help              Show this help message
    -d, --domain DOMAIN     Add domain (can be used multiple times)
    -i, --ip IP             Add IP address (can be used multiple times)
    -o, --output DIR        Output directory (default: $DEFAULT_OUTPUT_DIR)
    -y, --days DAYS         Certificate validity in days (default: $DEFAULT_DAYS)
    -b, --bits BITS         RSA key size (default: $DEFAULT_BITS)
    -q, --quick             Quick mode with localhost defaults

EXAMPLES:
    # Interactive mode (recommended for first-time users)
    ./$(basename "$0")
    
    # Quick localhost setup
    ./$(basename "$0") --quick
    
    # Specify domains and IPs
    ./$(basename "$0") -d example.com -d www.example.com -i 192.168.1.1

EOF
}

# Check dependencies
check_dependencies() {
    if ! command -v openssl &> /dev/null; then
        echo -e "${RED}✗ Error: openssl is not installed${NC}"
        echo -e "${YELLOW}Please install openssl:${NC}"
        echo "  • Ubuntu/Debian: sudo apt-get install openssl"
        echo "  • RHEL/CentOS: sudo yum install openssl"
        echo "  • macOS: brew install openssl"
        exit 1
    fi
}

# Validate IP address
is_valid_ip() {
    local ip=$1
    local regex='^([0-9]{1,3}\.){3}[0-9]{1,3}$'
    
    if [[ ! $ip =~ $regex ]]; then
        return 1
    fi
    
    local IFS='.'
    local octets=($ip)
    for octet in "${octets[@]}"; do
        if ((octet > 255)); then
            return 1
        fi
    done
    
    return 0
}

# Validate domain name
is_valid_domain() {
    local domain=$1
    local regex='^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)*[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?$'
    
    if [[ $domain =~ $regex ]] || [[ $domain == "localhost" ]]; then
        return 0
    fi
    return 1
}

# Interactive mode
interactive_mode() {
    echo -e "${BOLD}Certificate Configuration${NC}"
    echo -e "${YELLOW}Press Enter to use defaults shown in [brackets]${NC}\n"
    
    # Domain names
    echo -e "${BOLD}Domain Names:${NC}"
    echo "Enter domain names (one per line, empty line to finish)"
    echo -e "${YELLOW}[Default: localhost]${NC}"
    
    local has_input=false
    while true; do
        read -rp "> " domain
        if [[ -z "$domain" ]]; then
            break
        fi
        
        if is_valid_domain "$domain"; then
            DOMAINS+=("$domain")
            has_input=true
            echo -e "${GREEN}✓ Added: $domain${NC}"
        else
            echo -e "${RED}✗ Invalid domain: $domain${NC}"
        fi
    done
    
    # Add localhost if no domains specified
    if [[ ${#DOMAINS[@]} -eq 0 ]]; then
        DOMAINS+=("localhost")
        echo -e "${GREEN}✓ Using default: localhost${NC}"
    fi
    
    echo
    
    # IP addresses
    echo -e "${BOLD}IP Addresses (optional):${NC}"
    echo "Enter IP addresses (one per line, empty line to finish)"
    echo -e "${YELLOW}[Default: 127.0.0.1]${NC}"
    
    has_input=false
    while true; do
        read -rp "> " ip
        if [[ -z "$ip" ]]; then
            break
        fi
        
        if is_valid_ip "$ip"; then
            IP_ADDRESSES+=("$ip")
            has_input=true
            echo -e "${GREEN}✓ Added: $ip${NC}"
        else
            echo -e "${RED}✗ Invalid IP: $ip${NC}"
        fi
    done
    
    # Add 127.0.0.1 if localhost is in domains and no IPs specified
    if [[ ${#IP_ADDRESSES[@]} -eq 0 ]] && [[ " ${DOMAINS[@]} " =~ " localhost " ]]; then
        IP_ADDRESSES+=("127.0.0.1")
        echo -e "${GREEN}✓ Using default: 127.0.0.1${NC}"
    fi
    
    echo
    
    # Certificate validity
    read -rp "Certificate validity in days [$DEFAULT_DAYS]: " input_days
    if [[ -n "$input_days" ]]; then
        if [[ "$input_days" =~ ^[0-9]+$ ]]; then
            DAYS="$input_days"
        else
            echo -e "${YELLOW}⚠ Invalid input, using default: $DEFAULT_DAYS${NC}"
        fi
    fi
    
    # Output directory
    read -rp "Output directory [$DEFAULT_OUTPUT_DIR]: " input_dir
    if [[ -n "$input_dir" ]]; then
        OUTPUT_DIR="$input_dir"
    fi
    
    echo
}

# Quick mode
quick_mode() {
    echo -e "${GREEN}Quick mode: Using localhost defaults${NC}"
    DOMAINS+=("localhost")
    IP_ADDRESSES+=("127.0.0.1")
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                print_help
                exit 0
                ;;
            -d|--domain)
                if [[ -z "${2:-}" ]]; then
                    echo -e "${RED}Error: --domain requires an argument${NC}"
                    exit 1
                fi
                if is_valid_domain "$2"; then
                    DOMAINS+=("$2")
                else
                    echo -e "${RED}Error: Invalid domain: $2${NC}"
                    exit 1
                fi
                shift 2
                ;;
            -i|--ip)
                if [[ -z "${2:-}" ]]; then
                    echo -e "${RED}Error: --ip requires an argument${NC}"
                    exit 1
                fi
                if is_valid_ip "$2"; then
                    IP_ADDRESSES+=("$2")
                else
                    echo -e "${RED}Error: Invalid IP: $2${NC}"
                    exit 1
                fi
                shift 2
                ;;
            -o|--output)
                if [[ -z "${2:-}" ]]; then
                    echo -e "${RED}Error: --output requires an argument${NC}"
                    exit 1
                fi
                OUTPUT_DIR="$2"
                shift 2
                ;;
            -y|--days)
                if [[ -z "${2:-}" ]] || [[ ! "$2" =~ ^[0-9]+$ ]]; then
                    echo -e "${RED}Error: --days requires a numeric argument${NC}"
                    exit 1
                fi
                DAYS="$2"
                shift 2
                ;;
            -b|--bits)
                if [[ -z "${2:-}" ]] || [[ ! "$2" =~ ^[0-9]+$ ]]; then
                    echo -e "${RED}Error: --bits requires a numeric argument${NC}"
                    exit 1
                fi
                BITS="$2"
                shift 2
                ;;
            -q|--quick)
                quick_mode
                shift
                ;;
            *)
                echo -e "${RED}Error: Unknown option: $1${NC}"
                print_help
                exit 1
                ;;
        esac
    done
}

# Create OpenSSL config
create_openssl_config() {
    local config_file
    config_file=$(mktemp)
    
    cat > "$config_file" << EOF
[req]
default_bits = $BITS
prompt = no
default_md = sha256
distinguished_name = dn
req_extensions = v3_req

[dn]
C = US
ST = State
L = City
O = Organization
OU = Development
CN = $COMMON_NAME

[v3_req]
subjectAltName = @alt_names

[alt_names]
EOF
    
    # Add domains
    local idx=1
    for domain in "${DOMAINS[@]}"; do
        echo "DNS.$idx = $domain" >> "$config_file"
        ((idx++))
    done
    
    # Add IP addresses
    idx=1
    for ip in "${IP_ADDRESSES[@]}"; do
        echo "IP.$idx = $ip" >> "$config_file"
        ((idx++))
    done
    
    echo "$config_file"
}

# Generate certificate
generate_certificate() {
    # Set common name (first domain or IP)
    if [[ ${#DOMAINS[@]} -gt 0 ]]; then
        COMMON_NAME="${DOMAINS[0]}"
    elif [[ ${#IP_ADDRESSES[@]} -gt 0 ]]; then
        COMMON_NAME="${IP_ADDRESSES[0]}"
    else
        echo -e "${RED}Error: No domains or IP addresses specified${NC}"
        exit 1
    fi
    
    # Create output directory if it doesn't exist
    if [[ ! -d "$OUTPUT_DIR" ]]; then
        echo -e "${YELLOW}Creating output directory: $OUTPUT_DIR${NC}"
        mkdir -p "$OUTPUT_DIR" || {
            echo -e "${RED}Error: Failed to create directory: $OUTPUT_DIR${NC}"
            exit 1
        }
    fi
    
    # Set paths
    CERT_PATH="$OUTPUT_DIR/$DEFAULT_CERT_NAME"
    KEY_PATH="$OUTPUT_DIR/$DEFAULT_KEY_NAME"
    
    # Create OpenSSL config
    local config_file
    config_file=$(create_openssl_config)
    
    echo -e "\n${BOLD}Generating Certificate...${NC}"
    echo "• Common Name: $COMMON_NAME"
    echo "• Validity: $DAYS days"
    echo "• Key Size: $BITS bits"
    echo "• Domains: ${DOMAINS[*]:-none}"
    echo "• IPs: ${IP_ADDRESSES[*]:-none}"
    echo
    
    # Generate private key and certificate
    openssl req -x509 \
        -nodes \
        -days "$DAYS" \
        -newkey "rsa:$BITS" \
        -keyout "$KEY_PATH" \
        -out "$CERT_PATH" \
        -config "$config_file" \
        -extensions v3_req 2>/dev/null || {
            echo -e "${RED}Error: Certificate generation failed${NC}"
            rm -f "$config_file"
            exit 1
        }
    
    # Clean up config file
    rm -f "$config_file"
    
    # Set appropriate permissions
    chmod 600 "$KEY_PATH"
    chmod 644 "$CERT_PATH"
    
    echo -e "${GREEN}✓ Certificate generated successfully!${NC}\n"
}

# Display certificate info
display_certificate_info() {
    echo -e "${BOLD}Certificate Information:${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    # Display basic info
    openssl x509 -in "$CERT_PATH" -noout -subject -issuer -dates | sed 's/^/  /'
    
    echo
    echo -e "${BOLD}Subject Alternative Names:${NC}"
    openssl x509 -in "$CERT_PATH" -noout -text | \
        grep -A 1 "Subject Alternative Name" | \
        tail -1 | \
        sed 's/^/  /'
    
    echo
    echo -e "${BOLD}Files Created:${NC}"
    echo "  • Certificate: $CERT_PATH"
    echo "  • Private Key: $KEY_PATH"
    
    
    echo -e "${YELLOW}⚠ Warning: This is a self-signed certificate.${NC}"
    echo "  Browsers will show a security warning. This is expected."
    echo "  You will need to accept the certificate to proceed."
}

# Main function
main() {
    print_banner
    check_dependencies
    
    # Parse command line arguments
    parse_args "$@"
    
    # If no arguments provided and no domains/IPs set, run interactive mode
    if [[ ${#DOMAINS[@]} -eq 0 ]] && [[ ${#IP_ADDRESSES[@]} -eq 0 ]]; then
        interactive_mode
    fi
    
    # Generate the certificate
    generate_certificate
    
    # Display certificate information
    display_certificate_info
    
    echo -e "\n${GREEN}${BOLD}✓ Success!${NC} Your self-signed certificate is ready to use."
}

# Run main function
main "$@"